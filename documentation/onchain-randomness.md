# On-Chain Randomness

## Overview

ElizaICP uses ICP's `raw_rand()` to generate cryptographically secure randomness that is:
- **Unpredictable** - Cannot be known before generation
- **Unbiasable** - Cannot be influenced by any party
- **Verifiable** - Can be independently confirmed on-chain

## How `raw_rand` Works

### The Call
```motoko
import IC "ic:aaaaa-aa";  // Management canister

let seed : Blob = await IC.raw_rand();  // 32 random bytes
```

### Under the Hood

1. **Request sent** to management canister (pseudo-principal `aaaaa-aa`)
2. **Threshold BLS signatures** generated by subnet replicas
3. **Consensus required** - 2/3 of replicas must agree
4. **32 bytes returned** - cryptographically uniform

### Security Guarantees

| Threat | Protection |
|--------|------------|
| Developer bias | Cannot predict output |
| Single node manipulation | 2/3 consensus required |
| Replay attacks | Each call produces new randomness |
| Front-running | Randomness unknown until after call |

## How We Use It

### Token Creation
```motoko
public shared func create_meme_token(arg: CreateMemeTokenArg) : async CreateResponse {
  // 1. Generate random seed
  let randomBlob = await IC.raw_rand();
  
  // 2. Create token with seed
  let tokenInfo = {
    id = generateId();
    seed = randomBlob;  // Stored for verification
    // ... other fields
  };
  
  // 3. Store immutably
  tokens.put(tokenInfo.id, tokenInfo);
  
  // 4. Return seed to user
  { requestId = tokenInfo.id; seed = randomBlob }
}
```

### Verification Flow
```
User creates token
       │
       ▼
Canister calls raw_rand()
       │
       ▼
Seed stored on-chain
       │
       ▼
User receives seed hash
       │
       ▼
Anyone can query canister ──► Compare seed
```

## Use Cases

### Fair Token Allocation
```motoko
// Deterministically shuffle airdrop recipients
let shuffled = deterministicShuffle(recipients, seed);
```

### Lottery Winners
```motoko
// Pick winner from seed
let winnerIndex = seedToInt(seed) % participants.size();
```

### NFT Trait Generation
```motoko
// Use seed for traits
let traits = expandSeed(seed, numTraits);
```

## Verification Tools

### Web UI
Go to `/verify` → Enter request ID → See seed hash

### CLI
```bash
dfx canister call token_factory get_token_status '("abc123-0")'
```

### Direct Query
```typescript
const actor = getTokenFactoryActor();
const { info } = await actor.get_token_status("abc123-0");
console.log(info.seed);  // 32 bytes
```

## Technical Details

| Property | Value |
|----------|-------|
| Source | Management canister (`aaaaa-aa`) |
| Method | `raw_rand() : async Blob` |
| Output | 32 bytes (256 bits) |
| Algorithm | Threshold BLS signatures |
| Consensus | 2/3 subnet replicas |
| Latency | ~2 seconds |
| Cost | ~0.002 cycles per call |

## References

- [ICP Randomness Docs](https://internetcomputer.org/docs/current/developer-docs/smart-contracts/advanced-features/randomness)
- [Management Canister Interface](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-raw_rand)
- [Threshold BLS Explainer](https://eprint.iacr.org/2002/118.pdf)
